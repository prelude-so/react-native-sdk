// This file was autogenerated by some hot garbage in the `uniffi` crate.
// Trust me, you don't want to mess with it!

// swiftlint:disable all
import Foundation

// Depending on the consumer's build setup, the low-level FFI code
// might be in a separate module, or it might be compiled inline into
// this module. This is a bit of light hackery to work with both.
#if canImport(PreludeCore)
import PreludeCore
#endif

fileprivate extension RustBuffer {
    // Allocate a new buffer, copying the contents of a `UInt8` array.
    init(bytes: [UInt8]) {
        let rbuf = bytes.withUnsafeBufferPointer { ptr in
            RustBuffer.from(ptr)
        }
        self.init(capacity: rbuf.capacity, len: rbuf.len, data: rbuf.data)
    }

    static func empty() -> RustBuffer {
        RustBuffer(capacity: 0, len:0, data: nil)
    }

    static func from(_ ptr: UnsafeBufferPointer<UInt8>) -> RustBuffer {
        try! rustCall { ffi_prelude_rustbuffer_from_bytes(ForeignBytes(bufferPointer: ptr), $0) }
    }

    // Frees the buffer in place.
    // The buffer must not be used after this is called.
    func deallocate() {
        try! rustCall { ffi_prelude_rustbuffer_free(self, $0) }
    }
}

fileprivate extension ForeignBytes {
    init(bufferPointer: UnsafeBufferPointer<UInt8>) {
        self.init(len: Int32(bufferPointer.count), data: bufferPointer.baseAddress)
    }
}

// For every type used in the interface, we provide helper methods for conveniently
// lifting and lowering that type from C-compatible data, and for reading and writing
// values of that type in a buffer.

// Helper classes/extensions that don't change.
// Someday, this will be in a library of its own.

fileprivate extension Data {
    init(rustBuffer: RustBuffer) {
        self.init(
            bytesNoCopy: rustBuffer.data!,
            count: Int(rustBuffer.len),
            deallocator: .none
        )
    }
}

// Define reader functionality.  Normally this would be defined in a class or
// struct, but we use standalone functions instead in order to make external
// types work.
//
// With external types, one swift source file needs to be able to call the read
// method on another source file's FfiConverter, but then what visibility
// should Reader have?
// - If Reader is fileprivate, then this means the read() must also
//   be fileprivate, which doesn't work with external types.
// - If Reader is internal/public, we'll get compile errors since both source
//   files will try define the same type.
//
// Instead, the read() method and these helper functions input a tuple of data

fileprivate func createReader(data: Data) -> (data: Data, offset: Data.Index) {
    (data: data, offset: 0)
}

// Reads an integer at the current offset, in big-endian order, and advances
// the offset on success. Throws if reading the integer would move the
// offset past the end of the buffer.
fileprivate func readInt<T: FixedWidthInteger>(_ reader: inout (data: Data, offset: Data.Index)) throws -> T {
    let range = reader.offset..<reader.offset + MemoryLayout<T>.size
    guard reader.data.count >= range.upperBound else {
        throw UniffiInternalError.bufferOverflow
    }
    if T.self == UInt8.self {
        let value = reader.data[reader.offset]
        reader.offset += 1
        return value as! T
    }
    var value: T = 0
    let _ = withUnsafeMutableBytes(of: &value, { reader.data.copyBytes(to: $0, from: range)})
    reader.offset = range.upperBound
    return value.bigEndian
}

// Reads an arbitrary number of bytes, to be used to read
// raw bytes, this is useful when lifting strings
fileprivate func readBytes(_ reader: inout (data: Data, offset: Data.Index), count: Int) throws -> Array<UInt8> {
    let range = reader.offset..<(reader.offset+count)
    guard reader.data.count >= range.upperBound else {
        throw UniffiInternalError.bufferOverflow
    }
    var value = [UInt8](repeating: 0, count: count)
    value.withUnsafeMutableBufferPointer({ buffer in
        reader.data.copyBytes(to: buffer, from: range)
    })
    reader.offset = range.upperBound
    return value
}

// Reads a float at the current offset.
fileprivate func readFloat(_ reader: inout (data: Data, offset: Data.Index)) throws -> Float {
    return Float(bitPattern: try readInt(&reader))
}

// Reads a float at the current offset.
fileprivate func readDouble(_ reader: inout (data: Data, offset: Data.Index)) throws -> Double {
    return Double(bitPattern: try readInt(&reader))
}

// Indicates if the offset has reached the end of the buffer.
fileprivate func hasRemaining(_ reader: (data: Data, offset: Data.Index)) -> Bool {
    return reader.offset < reader.data.count
}

// Define writer functionality.  Normally this would be defined in a class or
// struct, but we use standalone functions instead in order to make external
// types work.  See the above discussion on Readers for details.

fileprivate func createWriter() -> [UInt8] {
    return []
}

fileprivate func writeBytes<S>(_ writer: inout [UInt8], _ byteArr: S) where S: Sequence, S.Element == UInt8 {
    writer.append(contentsOf: byteArr)
}

// Writes an integer in big-endian order.
//
// Warning: make sure what you are trying to write
// is in the correct type!
fileprivate func writeInt<T: FixedWidthInteger>(_ writer: inout [UInt8], _ value: T) {
    var value = value.bigEndian
    withUnsafeBytes(of: &value) { writer.append(contentsOf: $0) }
}

fileprivate func writeFloat(_ writer: inout [UInt8], _ value: Float) {
    writeInt(&writer, value.bitPattern)
}

fileprivate func writeDouble(_ writer: inout [UInt8], _ value: Double) {
    writeInt(&writer, value.bitPattern)
}

// Protocol for types that transfer other types across the FFI. This is
// analogous to the Rust trait of the same name.
fileprivate protocol FfiConverter {
    associatedtype FfiType
    associatedtype SwiftType

    static func lift(_ value: FfiType) throws -> SwiftType
    static func lower(_ value: SwiftType) -> FfiType
    static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType
    static func write(_ value: SwiftType, into buf: inout [UInt8])
}

// Types conforming to `Primitive` pass themselves directly over the FFI.
fileprivate protocol FfiConverterPrimitive: FfiConverter where FfiType == SwiftType { }

extension FfiConverterPrimitive {
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    internal static func lift(_ value: FfiType) throws -> SwiftType {
        return value
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    internal static func lower(_ value: SwiftType) -> FfiType {
        return value
    }
}

// Types conforming to `FfiConverterRustBuffer` lift and lower into a `RustBuffer`.
// Used for complex types where it's hard to write a custom lift/lower.
fileprivate protocol FfiConverterRustBuffer: FfiConverter where FfiType == RustBuffer {}

extension FfiConverterRustBuffer {
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    internal static func lift(_ buf: RustBuffer) throws -> SwiftType {
        var reader = createReader(data: Data(rustBuffer: buf))
        let value = try read(from: &reader)
        if hasRemaining(reader) {
            throw UniffiInternalError.incompleteData
        }
        buf.deallocate()
        return value
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    internal static func lower(_ value: SwiftType) -> RustBuffer {
          var writer = createWriter()
          write(value, into: &writer)
          return RustBuffer(bytes: writer)
    }
}
// An error type for FFI errors. These errors occur at the UniFFI level, not
// the library level.
fileprivate enum UniffiInternalError: LocalizedError {
    case bufferOverflow
    case incompleteData
    case unexpectedOptionalTag
    case unexpectedEnumCase
    case unexpectedNullPointer
    case unexpectedRustCallStatusCode
    case unexpectedRustCallError
    case unexpectedStaleHandle
    case rustPanic(_ message: String)

    internal var errorDescription: String? {
        switch self {
        case .bufferOverflow: return "Reading the requested value would read past the end of the buffer"
        case .incompleteData: return "The buffer still has data after lifting its containing value"
        case .unexpectedOptionalTag: return "Unexpected optional tag; should be 0 or 1"
        case .unexpectedEnumCase: return "Raw enum value doesn't match any cases"
        case .unexpectedNullPointer: return "Raw pointer value was null"
        case .unexpectedRustCallStatusCode: return "Unexpected RustCallStatus code"
        case .unexpectedRustCallError: return "CALL_ERROR but no errorClass specified"
        case .unexpectedStaleHandle: return "The object in the handle map has been dropped already"
        case let .rustPanic(message): return message
        }
    }
}

fileprivate extension NSLock {
    func withLock<T>(f: () throws -> T) rethrows -> T {
        self.lock()
        defer { self.unlock() }
        return try f()
    }
}

fileprivate let CALL_SUCCESS: Int8 = 0
fileprivate let CALL_ERROR: Int8 = 1
fileprivate let CALL_UNEXPECTED_ERROR: Int8 = 2
fileprivate let CALL_CANCELLED: Int8 = 3

fileprivate extension RustCallStatus {
    init() {
        self.init(
            code: CALL_SUCCESS,
            errorBuf: RustBuffer.init(
                capacity: 0,
                len: 0,
                data: nil
            )
        )
    }
}

private func rustCall<T>(_ callback: (UnsafeMutablePointer<RustCallStatus>) -> T) throws -> T {
    let neverThrow: ((RustBuffer) throws -> Never)? = nil
    return try makeRustCall(callback, errorHandler: neverThrow)
}

private func rustCallWithError<T, E: Swift.Error>(
    _ errorHandler: @escaping (RustBuffer) throws -> E,
    _ callback: (UnsafeMutablePointer<RustCallStatus>) -> T) throws -> T {
    try makeRustCall(callback, errorHandler: errorHandler)
}

private func makeRustCall<T, E: Swift.Error>(
    _ callback: (UnsafeMutablePointer<RustCallStatus>) -> T,
    errorHandler: ((RustBuffer) throws -> E)?
) throws -> T {
    uniffiEnsurePreludeInitialized()
    var callStatus = RustCallStatus.init()
    let returnedVal = callback(&callStatus)
    try uniffiCheckCallStatus(callStatus: callStatus, errorHandler: errorHandler)
    return returnedVal
}

private func uniffiCheckCallStatus<E: Swift.Error>(
    callStatus: RustCallStatus,
    errorHandler: ((RustBuffer) throws -> E)?
) throws {
    switch callStatus.code {
        case CALL_SUCCESS:
            return

        case CALL_ERROR:
            if let errorHandler = errorHandler {
                throw try errorHandler(callStatus.errorBuf)
            } else {
                callStatus.errorBuf.deallocate()
                throw UniffiInternalError.unexpectedRustCallError
            }

        case CALL_UNEXPECTED_ERROR:
            // When the rust code sees a panic, it tries to construct a RustBuffer
            // with the message.  But if that code panics, then it just sends back
            // an empty buffer.
            if callStatus.errorBuf.len > 0 {
                throw UniffiInternalError.rustPanic(try FfiConverterString.lift(callStatus.errorBuf))
            } else {
                callStatus.errorBuf.deallocate()
                throw UniffiInternalError.rustPanic("Rust panic")
            }

        case CALL_CANCELLED:
            fatalError("Cancellation not supported yet")

        default:
            throw UniffiInternalError.unexpectedRustCallStatusCode
    }
}

private func uniffiTraitInterfaceCall<T>(
    callStatus: UnsafeMutablePointer<RustCallStatus>,
    makeCall: () throws -> T,
    writeReturn: (T) -> ()
) {
    do {
        try writeReturn(makeCall())
    } catch let error {
        callStatus.pointee.code = CALL_UNEXPECTED_ERROR
        callStatus.pointee.errorBuf = FfiConverterString.lower(String(describing: error))
    }
}

private func uniffiTraitInterfaceCallWithError<T, E>(
    callStatus: UnsafeMutablePointer<RustCallStatus>,
    makeCall: () throws -> T,
    writeReturn: (T) -> (),
    lowerError: (E) -> RustBuffer
) {
    do {
        try writeReturn(makeCall())
    } catch let error as E {
        callStatus.pointee.code = CALL_ERROR
        callStatus.pointee.errorBuf = lowerError(error)
    } catch {
        callStatus.pointee.code = CALL_UNEXPECTED_ERROR
        callStatus.pointee.errorBuf = FfiConverterString.lower(String(describing: error))
    }
}
fileprivate final class UniffiHandleMap<T>: @unchecked Sendable {
    // All mutation happens with this lock held, which is why we implement @unchecked Sendable.
    private let lock = NSLock()
    private var map: [UInt64: T] = [:]
    private var currentHandle: UInt64 = 1

    func insert(obj: T) -> UInt64 {
        lock.withLock {
            let handle = currentHandle
            currentHandle += 1
            map[handle] = obj
            return handle
        }
    }

     func get(handle: UInt64) throws -> T {
        try lock.withLock {
            guard let obj = map[handle] else {
                throw UniffiInternalError.unexpectedStaleHandle
            }
            return obj
        }
    }

    @discardableResult
    func remove(handle: UInt64) throws -> T {
        try lock.withLock {
            guard let obj = map.removeValue(forKey: handle) else {
                throw UniffiInternalError.unexpectedStaleHandle
            }
            return obj
        }
    }

    var count: Int {
        get {
            map.count
        }
    }
}


// Public interface members begin here.


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterInt32: FfiConverterPrimitive {
    typealias FfiType = Int32
    typealias SwiftType = Int32

    internal static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Int32 {
        return try lift(readInt(&buf))
    }

    internal static func write(_ value: Int32, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterInt64: FfiConverterPrimitive {
    typealias FfiType = Int64
    typealias SwiftType = Int64

    internal static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Int64 {
        return try lift(readInt(&buf))
    }

    internal static func write(_ value: Int64, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterFloat: FfiConverterPrimitive {
    typealias FfiType = Float
    typealias SwiftType = Float

    internal static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Float {
        return try lift(readFloat(&buf))
    }

    internal static func write(_ value: Float, into buf: inout [UInt8]) {
        writeFloat(&buf, lower(value))
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterBool : FfiConverter {
    typealias FfiType = Int8
    typealias SwiftType = Bool

    internal static func lift(_ value: Int8) throws -> Bool {
        return value != 0
    }

    internal static func lower(_ value: Bool) -> Int8 {
        return value ? 1 : 0
    }

    internal static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Bool {
        return try lift(readInt(&buf))
    }

    internal static func write(_ value: Bool, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterString: FfiConverter {
    typealias SwiftType = String
    typealias FfiType = RustBuffer

    internal static func lift(_ value: RustBuffer) throws -> String {
        defer {
            value.deallocate()
        }
        if value.data == nil {
            return String()
        }
        let bytes = UnsafeBufferPointer<UInt8>(start: value.data!, count: Int(value.len))
        return String(bytes: bytes, encoding: String.Encoding.utf8)!
    }

    internal static func lower(_ value: String) -> RustBuffer {
        return value.utf8CString.withUnsafeBufferPointer { ptr in
            // The swift string gives us int8_t, we want uint8_t.
            ptr.withMemoryRebound(to: UInt8.self) { ptr in
                // The swift string gives us a trailing null byte, we don't want it.
                let buf = UnsafeBufferPointer(rebasing: ptr.prefix(upTo: ptr.count - 1))
                return RustBuffer.from(buf)
            }
        }
    }

    internal static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> String {
        let len: Int32 = try readInt(&buf)
        return String(bytes: try readBytes(&buf, count: Int(len)), encoding: String.Encoding.utf8)!
    }

    internal static func write(_ value: String, into buf: inout [UInt8]) {
        let len = Int32(value.utf8.count)
        writeInt(&buf, len)
        writeBytes(&buf, value.utf8)
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterData: FfiConverterRustBuffer {
    typealias SwiftType = Data

    internal static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Data {
        let len: Int32 = try readInt(&buf)
        return Data(try readBytes(&buf, count: Int(len)))
    }

    internal static func write(_ value: Data, into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        writeBytes(&buf, value)
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterTimestamp: FfiConverterRustBuffer {
    typealias SwiftType = Date

    internal static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Date {
        let seconds: Int64 = try readInt(&buf)
        let nanoseconds: UInt32 = try readInt(&buf)
        if seconds >= 0 {
            let delta = Double(seconds) + (Double(nanoseconds) / 1.0e9)
            return Date.init(timeIntervalSince1970: delta)
        } else {
            let delta = Double(seconds) - (Double(nanoseconds) / 1.0e9)
            return Date.init(timeIntervalSince1970: delta)
        }
    }

    internal static func write(_ value: Date, into buf: inout [UInt8]) {
        var delta = value.timeIntervalSince1970
        var sign: Int64 = 1
        if delta < 0 {
            // The nanoseconds portion of the epoch offset must always be
            // positive, to simplify the calculation we will use the absolute
            // value of the offset.
            sign = -1
            delta = -delta
        }
        if delta.rounded(.down) > Double(Int64.max) {
            fatalError("Timestamp overflow, exceeds max bounds supported by Uniffi")
        }
        let seconds = Int64(delta)
        let nanoseconds = UInt32((delta - Double(seconds)) * 1.0e9)
        writeInt(&buf, sign * seconds)
        writeInt(&buf, nanoseconds)
    }
}


internal struct Application {
    internal var name: String?
    internal var version: String?
    internal var platform: ApplicationPlatform?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    internal init(name: String?, version: String?, platform: ApplicationPlatform?) {
        self.name = name
        self.version = version
        self.platform = platform
    }
}

#if compiler(>=6)
extension Application: Sendable {}
#endif


extension Application: Equatable, Hashable {
    internal static func ==(lhs: Application, rhs: Application) -> Bool {
        if lhs.name != rhs.name {
            return false
        }
        if lhs.version != rhs.version {
            return false
        }
        if lhs.platform != rhs.platform {
            return false
        }
        return true
    }

    internal func hash(into hasher: inout Hasher) {
        hasher.combine(name)
        hasher.combine(version)
        hasher.combine(platform)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
internal struct FfiConverterTypeApplication: FfiConverterRustBuffer {
    internal static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Application {
        return
            try Application(
                name: FfiConverterOptionString.read(from: &buf), 
                version: FfiConverterOptionString.read(from: &buf), 
                platform: FfiConverterOptionTypeApplicationPlatform.read(from: &buf)
        )
    }

    internal static func write(_ value: Application, into buf: inout [UInt8]) {
        FfiConverterOptionString.write(value.name, into: &buf)
        FfiConverterOptionString.write(value.version, into: &buf)
        FfiConverterOptionTypeApplicationPlatform.write(value.platform, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
internal func FfiConverterTypeApplication_lift(_ buf: RustBuffer) throws -> Application {
    return try FfiConverterTypeApplication.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
internal func FfiConverterTypeApplication_lower(_ value: Application) -> RustBuffer {
    return FfiConverterTypeApplication.lower(value)
}


internal struct ApplicationAndroidPlatform {
    internal var packageName: String?
    internal var versionCode: Int32?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    internal init(packageName: String?, versionCode: Int32?) {
        self.packageName = packageName
        self.versionCode = versionCode
    }
}

#if compiler(>=6)
extension ApplicationAndroidPlatform: Sendable {}
#endif


extension ApplicationAndroidPlatform: Equatable, Hashable {
    internal static func ==(lhs: ApplicationAndroidPlatform, rhs: ApplicationAndroidPlatform) -> Bool {
        if lhs.packageName != rhs.packageName {
            return false
        }
        if lhs.versionCode != rhs.versionCode {
            return false
        }
        return true
    }

    internal func hash(into hasher: inout Hasher) {
        hasher.combine(packageName)
        hasher.combine(versionCode)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
internal struct FfiConverterTypeApplicationAndroidPlatform: FfiConverterRustBuffer {
    internal static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ApplicationAndroidPlatform {
        return
            try ApplicationAndroidPlatform(
                packageName: FfiConverterOptionString.read(from: &buf), 
                versionCode: FfiConverterOptionInt32.read(from: &buf)
        )
    }

    internal static func write(_ value: ApplicationAndroidPlatform, into buf: inout [UInt8]) {
        FfiConverterOptionString.write(value.packageName, into: &buf)
        FfiConverterOptionInt32.write(value.versionCode, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
internal func FfiConverterTypeApplicationAndroidPlatform_lift(_ buf: RustBuffer) throws -> ApplicationAndroidPlatform {
    return try FfiConverterTypeApplicationAndroidPlatform.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
internal func FfiConverterTypeApplicationAndroidPlatform_lower(_ value: ApplicationAndroidPlatform) -> RustBuffer {
    return FfiConverterTypeApplicationAndroidPlatform.lower(value)
}


internal struct ApplicationApplePlatform {
    internal var buildVersion: String?
    internal var bundleId: String?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    internal init(buildVersion: String?, bundleId: String?) {
        self.buildVersion = buildVersion
        self.bundleId = bundleId
    }
}

#if compiler(>=6)
extension ApplicationApplePlatform: Sendable {}
#endif


extension ApplicationApplePlatform: Equatable, Hashable {
    internal static func ==(lhs: ApplicationApplePlatform, rhs: ApplicationApplePlatform) -> Bool {
        if lhs.buildVersion != rhs.buildVersion {
            return false
        }
        if lhs.bundleId != rhs.bundleId {
            return false
        }
        return true
    }

    internal func hash(into hasher: inout Hasher) {
        hasher.combine(buildVersion)
        hasher.combine(bundleId)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
internal struct FfiConverterTypeApplicationApplePlatform: FfiConverterRustBuffer {
    internal static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ApplicationApplePlatform {
        return
            try ApplicationApplePlatform(
                buildVersion: FfiConverterOptionString.read(from: &buf), 
                bundleId: FfiConverterOptionString.read(from: &buf)
        )
    }

    internal static func write(_ value: ApplicationApplePlatform, into buf: inout [UInt8]) {
        FfiConverterOptionString.write(value.buildVersion, into: &buf)
        FfiConverterOptionString.write(value.bundleId, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
internal func FfiConverterTypeApplicationApplePlatform_lift(_ buf: RustBuffer) throws -> ApplicationApplePlatform {
    return try FfiConverterTypeApplicationApplePlatform.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
internal func FfiConverterTypeApplicationApplePlatform_lower(_ value: ApplicationApplePlatform) -> RustBuffer {
    return FfiConverterTypeApplicationApplePlatform.lower(value)
}


internal struct ApplicationWebPlatform {
    internal var userAgent: String?
    internal var connectionType: String?
    internal var rtt: Int32?
    internal var cookiesEnabled: Bool?
    internal var indexedDbEnabled: Bool?
    internal var localStorageEnabled: Bool?
    internal var doNotTrack: String?
    internal var multiTouchDevice: Bool?
    internal var mediaCapabilities: String?
    internal var maybeHeadless: Bool?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    internal init(userAgent: String?, connectionType: String?, rtt: Int32?, cookiesEnabled: Bool?, indexedDbEnabled: Bool?, localStorageEnabled: Bool?, doNotTrack: String?, multiTouchDevice: Bool?, mediaCapabilities: String?, maybeHeadless: Bool?) {
        self.userAgent = userAgent
        self.connectionType = connectionType
        self.rtt = rtt
        self.cookiesEnabled = cookiesEnabled
        self.indexedDbEnabled = indexedDbEnabled
        self.localStorageEnabled = localStorageEnabled
        self.doNotTrack = doNotTrack
        self.multiTouchDevice = multiTouchDevice
        self.mediaCapabilities = mediaCapabilities
        self.maybeHeadless = maybeHeadless
    }
}

#if compiler(>=6)
extension ApplicationWebPlatform: Sendable {}
#endif


extension ApplicationWebPlatform: Equatable, Hashable {
    internal static func ==(lhs: ApplicationWebPlatform, rhs: ApplicationWebPlatform) -> Bool {
        if lhs.userAgent != rhs.userAgent {
            return false
        }
        if lhs.connectionType != rhs.connectionType {
            return false
        }
        if lhs.rtt != rhs.rtt {
            return false
        }
        if lhs.cookiesEnabled != rhs.cookiesEnabled {
            return false
        }
        if lhs.indexedDbEnabled != rhs.indexedDbEnabled {
            return false
        }
        if lhs.localStorageEnabled != rhs.localStorageEnabled {
            return false
        }
        if lhs.doNotTrack != rhs.doNotTrack {
            return false
        }
        if lhs.multiTouchDevice != rhs.multiTouchDevice {
            return false
        }
        if lhs.mediaCapabilities != rhs.mediaCapabilities {
            return false
        }
        if lhs.maybeHeadless != rhs.maybeHeadless {
            return false
        }
        return true
    }

    internal func hash(into hasher: inout Hasher) {
        hasher.combine(userAgent)
        hasher.combine(connectionType)
        hasher.combine(rtt)
        hasher.combine(cookiesEnabled)
        hasher.combine(indexedDbEnabled)
        hasher.combine(localStorageEnabled)
        hasher.combine(doNotTrack)
        hasher.combine(multiTouchDevice)
        hasher.combine(mediaCapabilities)
        hasher.combine(maybeHeadless)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
internal struct FfiConverterTypeApplicationWebPlatform: FfiConverterRustBuffer {
    internal static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ApplicationWebPlatform {
        return
            try ApplicationWebPlatform(
                userAgent: FfiConverterOptionString.read(from: &buf), 
                connectionType: FfiConverterOptionString.read(from: &buf), 
                rtt: FfiConverterOptionInt32.read(from: &buf), 
                cookiesEnabled: FfiConverterOptionBool.read(from: &buf), 
                indexedDbEnabled: FfiConverterOptionBool.read(from: &buf), 
                localStorageEnabled: FfiConverterOptionBool.read(from: &buf), 
                doNotTrack: FfiConverterOptionString.read(from: &buf), 
                multiTouchDevice: FfiConverterOptionBool.read(from: &buf), 
                mediaCapabilities: FfiConverterOptionString.read(from: &buf), 
                maybeHeadless: FfiConverterOptionBool.read(from: &buf)
        )
    }

    internal static func write(_ value: ApplicationWebPlatform, into buf: inout [UInt8]) {
        FfiConverterOptionString.write(value.userAgent, into: &buf)
        FfiConverterOptionString.write(value.connectionType, into: &buf)
        FfiConverterOptionInt32.write(value.rtt, into: &buf)
        FfiConverterOptionBool.write(value.cookiesEnabled, into: &buf)
        FfiConverterOptionBool.write(value.indexedDbEnabled, into: &buf)
        FfiConverterOptionBool.write(value.localStorageEnabled, into: &buf)
        FfiConverterOptionString.write(value.doNotTrack, into: &buf)
        FfiConverterOptionBool.write(value.multiTouchDevice, into: &buf)
        FfiConverterOptionString.write(value.mediaCapabilities, into: &buf)
        FfiConverterOptionBool.write(value.maybeHeadless, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
internal func FfiConverterTypeApplicationWebPlatform_lift(_ buf: RustBuffer) throws -> ApplicationWebPlatform {
    return try FfiConverterTypeApplicationWebPlatform.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
internal func FfiConverterTypeApplicationWebPlatform_lower(_ value: ApplicationWebPlatform) -> RustBuffer {
    return FfiConverterTypeApplicationWebPlatform.lower(value)
}


internal struct Device {
    internal var platform: Platform?
    internal var bootTime: Date?
    internal var hostname: String?
    internal var kernelVersion: String?
    internal var osBuild: String?
    internal var osRelease: String?
    internal var osType: String?
    internal var systemName: String?
    internal var systemVersion: String?
    internal var vendorId: String?
    internal var name: String?
    internal var localeCurrent: String?
    internal var localePreferred: [String]?
    internal var timeZoneCurrent: String?
    internal var batteryLevel: Float?
    internal var batteryState: BatteryState?
    internal var fontsDigest: String?
    internal var simulator: Bool?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    internal init(platform: Platform?, bootTime: Date?, hostname: String?, kernelVersion: String?, osBuild: String?, osRelease: String?, osType: String?, systemName: String?, systemVersion: String?, vendorId: String?, name: String?, localeCurrent: String?, localePreferred: [String]?, timeZoneCurrent: String?, batteryLevel: Float?, batteryState: BatteryState?, fontsDigest: String?, simulator: Bool?) {
        self.platform = platform
        self.bootTime = bootTime
        self.hostname = hostname
        self.kernelVersion = kernelVersion
        self.osBuild = osBuild
        self.osRelease = osRelease
        self.osType = osType
        self.systemName = systemName
        self.systemVersion = systemVersion
        self.vendorId = vendorId
        self.name = name
        self.localeCurrent = localeCurrent
        self.localePreferred = localePreferred
        self.timeZoneCurrent = timeZoneCurrent
        self.batteryLevel = batteryLevel
        self.batteryState = batteryState
        self.fontsDigest = fontsDigest
        self.simulator = simulator
    }
}

#if compiler(>=6)
extension Device: Sendable {}
#endif


extension Device: Equatable, Hashable {
    internal static func ==(lhs: Device, rhs: Device) -> Bool {
        if lhs.platform != rhs.platform {
            return false
        }
        if lhs.bootTime != rhs.bootTime {
            return false
        }
        if lhs.hostname != rhs.hostname {
            return false
        }
        if lhs.kernelVersion != rhs.kernelVersion {
            return false
        }
        if lhs.osBuild != rhs.osBuild {
            return false
        }
        if lhs.osRelease != rhs.osRelease {
            return false
        }
        if lhs.osType != rhs.osType {
            return false
        }
        if lhs.systemName != rhs.systemName {
            return false
        }
        if lhs.systemVersion != rhs.systemVersion {
            return false
        }
        if lhs.vendorId != rhs.vendorId {
            return false
        }
        if lhs.name != rhs.name {
            return false
        }
        if lhs.localeCurrent != rhs.localeCurrent {
            return false
        }
        if lhs.localePreferred != rhs.localePreferred {
            return false
        }
        if lhs.timeZoneCurrent != rhs.timeZoneCurrent {
            return false
        }
        if lhs.batteryLevel != rhs.batteryLevel {
            return false
        }
        if lhs.batteryState != rhs.batteryState {
            return false
        }
        if lhs.fontsDigest != rhs.fontsDigest {
            return false
        }
        if lhs.simulator != rhs.simulator {
            return false
        }
        return true
    }

    internal func hash(into hasher: inout Hasher) {
        hasher.combine(platform)
        hasher.combine(bootTime)
        hasher.combine(hostname)
        hasher.combine(kernelVersion)
        hasher.combine(osBuild)
        hasher.combine(osRelease)
        hasher.combine(osType)
        hasher.combine(systemName)
        hasher.combine(systemVersion)
        hasher.combine(vendorId)
        hasher.combine(name)
        hasher.combine(localeCurrent)
        hasher.combine(localePreferred)
        hasher.combine(timeZoneCurrent)
        hasher.combine(batteryLevel)
        hasher.combine(batteryState)
        hasher.combine(fontsDigest)
        hasher.combine(simulator)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
internal struct FfiConverterTypeDevice: FfiConverterRustBuffer {
    internal static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Device {
        return
            try Device(
                platform: FfiConverterOptionTypePlatform.read(from: &buf), 
                bootTime: FfiConverterOptionTimestamp.read(from: &buf), 
                hostname: FfiConverterOptionString.read(from: &buf), 
                kernelVersion: FfiConverterOptionString.read(from: &buf), 
                osBuild: FfiConverterOptionString.read(from: &buf), 
                osRelease: FfiConverterOptionString.read(from: &buf), 
                osType: FfiConverterOptionString.read(from: &buf), 
                systemName: FfiConverterOptionString.read(from: &buf), 
                systemVersion: FfiConverterOptionString.read(from: &buf), 
                vendorId: FfiConverterOptionString.read(from: &buf), 
                name: FfiConverterOptionString.read(from: &buf), 
                localeCurrent: FfiConverterOptionString.read(from: &buf), 
                localePreferred: FfiConverterOptionSequenceString.read(from: &buf), 
                timeZoneCurrent: FfiConverterOptionString.read(from: &buf), 
                batteryLevel: FfiConverterOptionFloat.read(from: &buf), 
                batteryState: FfiConverterOptionTypeBatteryState.read(from: &buf), 
                fontsDigest: FfiConverterOptionString.read(from: &buf), 
                simulator: FfiConverterOptionBool.read(from: &buf)
        )
    }

    internal static func write(_ value: Device, into buf: inout [UInt8]) {
        FfiConverterOptionTypePlatform.write(value.platform, into: &buf)
        FfiConverterOptionTimestamp.write(value.bootTime, into: &buf)
        FfiConverterOptionString.write(value.hostname, into: &buf)
        FfiConverterOptionString.write(value.kernelVersion, into: &buf)
        FfiConverterOptionString.write(value.osBuild, into: &buf)
        FfiConverterOptionString.write(value.osRelease, into: &buf)
        FfiConverterOptionString.write(value.osType, into: &buf)
        FfiConverterOptionString.write(value.systemName, into: &buf)
        FfiConverterOptionString.write(value.systemVersion, into: &buf)
        FfiConverterOptionString.write(value.vendorId, into: &buf)
        FfiConverterOptionString.write(value.name, into: &buf)
        FfiConverterOptionString.write(value.localeCurrent, into: &buf)
        FfiConverterOptionSequenceString.write(value.localePreferred, into: &buf)
        FfiConverterOptionString.write(value.timeZoneCurrent, into: &buf)
        FfiConverterOptionFloat.write(value.batteryLevel, into: &buf)
        FfiConverterOptionTypeBatteryState.write(value.batteryState, into: &buf)
        FfiConverterOptionString.write(value.fontsDigest, into: &buf)
        FfiConverterOptionBool.write(value.simulator, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
internal func FfiConverterTypeDevice_lift(_ buf: RustBuffer) throws -> Device {
    return try FfiConverterTypeDevice.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
internal func FfiConverterTypeDevice_lower(_ value: Device) -> RustBuffer {
    return FfiConverterTypeDevice.lower(value)
}


internal struct DisplayResolution {
    internal var width: Int32
    internal var height: Int32

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    internal init(width: Int32, height: Int32) {
        self.width = width
        self.height = height
    }
}

#if compiler(>=6)
extension DisplayResolution: Sendable {}
#endif


extension DisplayResolution: Equatable, Hashable {
    internal static func ==(lhs: DisplayResolution, rhs: DisplayResolution) -> Bool {
        if lhs.width != rhs.width {
            return false
        }
        if lhs.height != rhs.height {
            return false
        }
        return true
    }

    internal func hash(into hasher: inout Hasher) {
        hasher.combine(width)
        hasher.combine(height)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
internal struct FfiConverterTypeDisplayResolution: FfiConverterRustBuffer {
    internal static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> DisplayResolution {
        return
            try DisplayResolution(
                width: FfiConverterInt32.read(from: &buf), 
                height: FfiConverterInt32.read(from: &buf)
        )
    }

    internal static func write(_ value: DisplayResolution, into buf: inout [UInt8]) {
        FfiConverterInt32.write(value.width, into: &buf)
        FfiConverterInt32.write(value.height, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
internal func FfiConverterTypeDisplayResolution_lift(_ buf: RustBuffer) throws -> DisplayResolution {
    return try FfiConverterTypeDisplayResolution.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
internal func FfiConverterTypeDisplayResolution_lower(_ value: DisplayResolution) -> RustBuffer {
    return FfiConverterTypeDisplayResolution.lower(value)
}


internal struct Hardware {
    internal var manufacturer: String?
    internal var model: String?
    internal var architecture: String?
    internal var cpuCount: Int32?
    internal var cpuFrequency: Int32?
    internal var memorySize: Int64?
    internal var displayResolution: DisplayResolution?
    internal var displayScale: Float?
    internal var displayPhysicalResolution: DisplayResolution?
    internal var displayPhysicalScale: Float?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    internal init(manufacturer: String?, model: String?, architecture: String?, cpuCount: Int32?, cpuFrequency: Int32?, memorySize: Int64?, displayResolution: DisplayResolution?, displayScale: Float?, displayPhysicalResolution: DisplayResolution?, displayPhysicalScale: Float?) {
        self.manufacturer = manufacturer
        self.model = model
        self.architecture = architecture
        self.cpuCount = cpuCount
        self.cpuFrequency = cpuFrequency
        self.memorySize = memorySize
        self.displayResolution = displayResolution
        self.displayScale = displayScale
        self.displayPhysicalResolution = displayPhysicalResolution
        self.displayPhysicalScale = displayPhysicalScale
    }
}

#if compiler(>=6)
extension Hardware: Sendable {}
#endif


extension Hardware: Equatable, Hashable {
    internal static func ==(lhs: Hardware, rhs: Hardware) -> Bool {
        if lhs.manufacturer != rhs.manufacturer {
            return false
        }
        if lhs.model != rhs.model {
            return false
        }
        if lhs.architecture != rhs.architecture {
            return false
        }
        if lhs.cpuCount != rhs.cpuCount {
            return false
        }
        if lhs.cpuFrequency != rhs.cpuFrequency {
            return false
        }
        if lhs.memorySize != rhs.memorySize {
            return false
        }
        if lhs.displayResolution != rhs.displayResolution {
            return false
        }
        if lhs.displayScale != rhs.displayScale {
            return false
        }
        if lhs.displayPhysicalResolution != rhs.displayPhysicalResolution {
            return false
        }
        if lhs.displayPhysicalScale != rhs.displayPhysicalScale {
            return false
        }
        return true
    }

    internal func hash(into hasher: inout Hasher) {
        hasher.combine(manufacturer)
        hasher.combine(model)
        hasher.combine(architecture)
        hasher.combine(cpuCount)
        hasher.combine(cpuFrequency)
        hasher.combine(memorySize)
        hasher.combine(displayResolution)
        hasher.combine(displayScale)
        hasher.combine(displayPhysicalResolution)
        hasher.combine(displayPhysicalScale)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
internal struct FfiConverterTypeHardware: FfiConverterRustBuffer {
    internal static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Hardware {
        return
            try Hardware(
                manufacturer: FfiConverterOptionString.read(from: &buf), 
                model: FfiConverterOptionString.read(from: &buf), 
                architecture: FfiConverterOptionString.read(from: &buf), 
                cpuCount: FfiConverterOptionInt32.read(from: &buf), 
                cpuFrequency: FfiConverterOptionInt32.read(from: &buf), 
                memorySize: FfiConverterOptionInt64.read(from: &buf), 
                displayResolution: FfiConverterOptionTypeDisplayResolution.read(from: &buf), 
                displayScale: FfiConverterOptionFloat.read(from: &buf), 
                displayPhysicalResolution: FfiConverterOptionTypeDisplayResolution.read(from: &buf), 
                displayPhysicalScale: FfiConverterOptionFloat.read(from: &buf)
        )
    }

    internal static func write(_ value: Hardware, into buf: inout [UInt8]) {
        FfiConverterOptionString.write(value.manufacturer, into: &buf)
        FfiConverterOptionString.write(value.model, into: &buf)
        FfiConverterOptionString.write(value.architecture, into: &buf)
        FfiConverterOptionInt32.write(value.cpuCount, into: &buf)
        FfiConverterOptionInt32.write(value.cpuFrequency, into: &buf)
        FfiConverterOptionInt64.write(value.memorySize, into: &buf)
        FfiConverterOptionTypeDisplayResolution.write(value.displayResolution, into: &buf)
        FfiConverterOptionFloat.write(value.displayScale, into: &buf)
        FfiConverterOptionTypeDisplayResolution.write(value.displayPhysicalResolution, into: &buf)
        FfiConverterOptionFloat.write(value.displayPhysicalScale, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
internal func FfiConverterTypeHardware_lift(_ buf: RustBuffer) throws -> Hardware {
    return try FfiConverterTypeHardware.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
internal func FfiConverterTypeHardware_lower(_ value: Hardware) -> RustBuffer {
    return FfiConverterTypeHardware.lower(value)
}


internal struct Network {
    internal var cellularData: Bool?
    internal var cellularTechnologies: [String]?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    internal init(cellularData: Bool?, cellularTechnologies: [String]?) {
        self.cellularData = cellularData
        self.cellularTechnologies = cellularTechnologies
    }
}

#if compiler(>=6)
extension Network: Sendable {}
#endif


extension Network: Equatable, Hashable {
    internal static func ==(lhs: Network, rhs: Network) -> Bool {
        if lhs.cellularData != rhs.cellularData {
            return false
        }
        if lhs.cellularTechnologies != rhs.cellularTechnologies {
            return false
        }
        return true
    }

    internal func hash(into hasher: inout Hasher) {
        hasher.combine(cellularData)
        hasher.combine(cellularTechnologies)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
internal struct FfiConverterTypeNetwork: FfiConverterRustBuffer {
    internal static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Network {
        return
            try Network(
                cellularData: FfiConverterOptionBool.read(from: &buf), 
                cellularTechnologies: FfiConverterOptionSequenceString.read(from: &buf)
        )
    }

    internal static func write(_ value: Network, into buf: inout [UInt8]) {
        FfiConverterOptionBool.write(value.cellularData, into: &buf)
        FfiConverterOptionSequenceString.write(value.cellularTechnologies, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
internal func FfiConverterTypeNetwork_lift(_ buf: RustBuffer) throws -> Network {
    return try FfiConverterTypeNetwork.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
internal func FfiConverterTypeNetwork_lower(_ value: Network) -> RustBuffer {
    return FfiConverterTypeNetwork.lower(value)
}


internal struct Signals {
    internal var id: String
    internal var timestamp: Date
    internal var application: Application
    internal var device: Device
    internal var hardware: Hardware
    internal var network: Network

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    internal init(id: String, timestamp: Date, application: Application, device: Device, hardware: Hardware, network: Network) {
        self.id = id
        self.timestamp = timestamp
        self.application = application
        self.device = device
        self.hardware = hardware
        self.network = network
    }
}

#if compiler(>=6)
extension Signals: Sendable {}
#endif


extension Signals: Equatable, Hashable {
    internal static func ==(lhs: Signals, rhs: Signals) -> Bool {
        if lhs.id != rhs.id {
            return false
        }
        if lhs.timestamp != rhs.timestamp {
            return false
        }
        if lhs.application != rhs.application {
            return false
        }
        if lhs.device != rhs.device {
            return false
        }
        if lhs.hardware != rhs.hardware {
            return false
        }
        if lhs.network != rhs.network {
            return false
        }
        return true
    }

    internal func hash(into hasher: inout Hasher) {
        hasher.combine(id)
        hasher.combine(timestamp)
        hasher.combine(application)
        hasher.combine(device)
        hasher.combine(hardware)
        hasher.combine(network)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
internal struct FfiConverterTypeSignals: FfiConverterRustBuffer {
    internal static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Signals {
        return
            try Signals(
                id: FfiConverterString.read(from: &buf), 
                timestamp: FfiConverterTimestamp.read(from: &buf), 
                application: FfiConverterTypeApplication.read(from: &buf), 
                device: FfiConverterTypeDevice.read(from: &buf), 
                hardware: FfiConverterTypeHardware.read(from: &buf), 
                network: FfiConverterTypeNetwork.read(from: &buf)
        )
    }

    internal static func write(_ value: Signals, into buf: inout [UInt8]) {
        FfiConverterString.write(value.id, into: &buf)
        FfiConverterTimestamp.write(value.timestamp, into: &buf)
        FfiConverterTypeApplication.write(value.application, into: &buf)
        FfiConverterTypeDevice.write(value.device, into: &buf)
        FfiConverterTypeHardware.write(value.hardware, into: &buf)
        FfiConverterTypeNetwork.write(value.network, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
internal func FfiConverterTypeSignals_lift(_ buf: RustBuffer) throws -> Signals {
    return try FfiConverterTypeSignals.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
internal func FfiConverterTypeSignals_lower(_ value: Signals) -> RustBuffer {
    return FfiConverterTypeSignals.lower(value)
}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

internal enum ApplicationPlatform {
    
    case android(ApplicationAndroidPlatform
    )
    case apple(ApplicationApplePlatform
    )
    case web(ApplicationWebPlatform
    )
}


#if compiler(>=6)
extension ApplicationPlatform: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
internal struct FfiConverterTypeApplicationPlatform: FfiConverterRustBuffer {
    typealias SwiftType = ApplicationPlatform

    internal static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ApplicationPlatform {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .android(try FfiConverterTypeApplicationAndroidPlatform.read(from: &buf)
        )
        
        case 2: return .apple(try FfiConverterTypeApplicationApplePlatform.read(from: &buf)
        )
        
        case 3: return .web(try FfiConverterTypeApplicationWebPlatform.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    internal static func write(_ value: ApplicationPlatform, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .android(v1):
            writeInt(&buf, Int32(1))
            FfiConverterTypeApplicationAndroidPlatform.write(v1, into: &buf)
            
        
        case let .apple(v1):
            writeInt(&buf, Int32(2))
            FfiConverterTypeApplicationApplePlatform.write(v1, into: &buf)
            
        
        case let .web(v1):
            writeInt(&buf, Int32(3))
            FfiConverterTypeApplicationWebPlatform.write(v1, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
internal func FfiConverterTypeApplicationPlatform_lift(_ buf: RustBuffer) throws -> ApplicationPlatform {
    return try FfiConverterTypeApplicationPlatform.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
internal func FfiConverterTypeApplicationPlatform_lower(_ value: ApplicationPlatform) -> RustBuffer {
    return FfiConverterTypeApplicationPlatform.lower(value)
}


extension ApplicationPlatform: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

internal enum BatteryState {
    
    case unspecified
    case unknown
    case unplugged
    case charging
    case full
}


#if compiler(>=6)
extension BatteryState: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
internal struct FfiConverterTypeBatteryState: FfiConverterRustBuffer {
    typealias SwiftType = BatteryState

    internal static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> BatteryState {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .unspecified
        
        case 2: return .unknown
        
        case 3: return .unplugged
        
        case 4: return .charging
        
        case 5: return .full
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    internal static func write(_ value: BatteryState, into buf: inout [UInt8]) {
        switch value {
        
        
        case .unspecified:
            writeInt(&buf, Int32(1))
        
        
        case .unknown:
            writeInt(&buf, Int32(2))
        
        
        case .unplugged:
            writeInt(&buf, Int32(3))
        
        
        case .charging:
            writeInt(&buf, Int32(4))
        
        
        case .full:
            writeInt(&buf, Int32(5))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
internal func FfiConverterTypeBatteryState_lift(_ buf: RustBuffer) throws -> BatteryState {
    return try FfiConverterTypeBatteryState.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
internal func FfiConverterTypeBatteryState_lower(_ value: BatteryState) -> RustBuffer {
    return FfiConverterTypeBatteryState.lower(value)
}


extension BatteryState: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

internal enum Platform {
    
    case unspecified
    case apple
    case android
    case web
}


#if compiler(>=6)
extension Platform: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
internal struct FfiConverterTypePlatform: FfiConverterRustBuffer {
    typealias SwiftType = Platform

    internal static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Platform {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .unspecified
        
        case 2: return .apple
        
        case 3: return .android
        
        case 4: return .web
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    internal static func write(_ value: Platform, into buf: inout [UInt8]) {
        switch value {
        
        
        case .unspecified:
            writeInt(&buf, Int32(1))
        
        
        case .apple:
            writeInt(&buf, Int32(2))
        
        
        case .android:
            writeInt(&buf, Int32(3))
        
        
        case .web:
            writeInt(&buf, Int32(4))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
internal func FfiConverterTypePlatform_lift(_ buf: RustBuffer) throws -> Platform {
    return try FfiConverterTypePlatform.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
internal func FfiConverterTypePlatform_lower(_ value: Platform) -> RustBuffer {
    return FfiConverterTypePlatform.lower(value)
}


extension Platform: Equatable, Hashable {}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionInt32: FfiConverterRustBuffer {
    typealias SwiftType = Int32?

    internal static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterInt32.write(value, into: &buf)
    }

    internal static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterInt32.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionInt64: FfiConverterRustBuffer {
    typealias SwiftType = Int64?

    internal static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterInt64.write(value, into: &buf)
    }

    internal static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterInt64.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionFloat: FfiConverterRustBuffer {
    typealias SwiftType = Float?

    internal static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterFloat.write(value, into: &buf)
    }

    internal static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterFloat.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionBool: FfiConverterRustBuffer {
    typealias SwiftType = Bool?

    internal static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterBool.write(value, into: &buf)
    }

    internal static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterBool.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionString: FfiConverterRustBuffer {
    typealias SwiftType = String?

    internal static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterString.write(value, into: &buf)
    }

    internal static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterString.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTimestamp: FfiConverterRustBuffer {
    typealias SwiftType = Date?

    internal static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTimestamp.write(value, into: &buf)
    }

    internal static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTimestamp.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeDisplayResolution: FfiConverterRustBuffer {
    typealias SwiftType = DisplayResolution?

    internal static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeDisplayResolution.write(value, into: &buf)
    }

    internal static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeDisplayResolution.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeApplicationPlatform: FfiConverterRustBuffer {
    typealias SwiftType = ApplicationPlatform?

    internal static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeApplicationPlatform.write(value, into: &buf)
    }

    internal static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeApplicationPlatform.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeBatteryState: FfiConverterRustBuffer {
    typealias SwiftType = BatteryState?

    internal static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeBatteryState.write(value, into: &buf)
    }

    internal static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeBatteryState.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypePlatform: FfiConverterRustBuffer {
    typealias SwiftType = Platform?

    internal static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypePlatform.write(value, into: &buf)
    }

    internal static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypePlatform.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionSequenceString: FfiConverterRustBuffer {
    typealias SwiftType = [String]?

    internal static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterSequenceString.write(value, into: &buf)
    }

    internal static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterSequenceString.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceString: FfiConverterRustBuffer {
    typealias SwiftType = [String]

    internal static func write(_ value: [String], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterString.write(item, into: &buf)
        }
    }

    internal static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [String] {
        let len: Int32 = try readInt(&buf)
        var seq = [String]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterString.read(from: &buf))
        }
        return seq
    }
}
internal func coreVersion() -> String  {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_prelude_fn_func_core_version($0
    )
})
}
internal func defaultEndpoint() -> String  {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_prelude_fn_func_default_endpoint($0
    )
})
}
internal func dispatchId() -> String  {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_prelude_fn_func_dispatch_id($0
    )
})
}
internal func generatePayload(signals: Signals, secret: String?) -> Data  {
    return try!  FfiConverterData.lift(try! rustCall() {
    uniffi_prelude_fn_func_generate_payload(
        FfiConverterTypeSignals_lower(signals),
        FfiConverterOptionString.lower(secret),$0
    )
})
}

private enum InitializationResult {
    case ok
    case contractVersionMismatch
    case apiChecksumMismatch
}
// Use a global variable to perform the versioning checks. Swift ensures that
// the code inside is only computed once.
private let initializationResult: InitializationResult = {
    // Get the bindings contract version from our ComponentInterface
    let bindings_contract_version = 29
    // Get the scaffolding contract version by calling the into the dylib
    let scaffolding_contract_version = ffi_prelude_uniffi_contract_version()
    if bindings_contract_version != scaffolding_contract_version {
        return InitializationResult.contractVersionMismatch
    }
    if (uniffi_prelude_checksum_func_core_version() != 23507) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_prelude_checksum_func_default_endpoint() != 33909) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_prelude_checksum_func_dispatch_id() != 42747) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_prelude_checksum_func_generate_payload() != 49015) {
        return InitializationResult.apiChecksumMismatch
    }

    return InitializationResult.ok
}()

// Make the ensure init function public so that other modules which have external type references to
// our types can call it.
internal func uniffiEnsurePreludeInitialized() {
    switch initializationResult {
    case .ok:
        break
    case .contractVersionMismatch:
        fatalError("UniFFI contract version mismatch: try cleaning and rebuilding your project")
    case .apiChecksumMismatch:
        fatalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
}

// swiftlint:enable all